// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2024 Datadog, Inc.

package waf

import (
	"context"
	"maps"
	"slices"
	"sync"
	"sync/atomic"

	"github.com/DataDog/appsec-internal-go/limiter"
	waf "github.com/DataDog/go-libddwaf/v3"

	"gopkg.in/DataDog/dd-trace-go.v1/internal/appsec/config"
	"gopkg.in/DataDog/dd-trace-go.v1/internal/log"
	"gopkg.in/DataDog/dd-trace-go.v1/internal/stacktrace"

	"gopkg.in/DataDog/dd-trace-go.v1/internal/appsec/dyngo"
	"gopkg.in/DataDog/dd-trace-go.v1/internal/appsec/emitter/trace"
)

type (
	ContextOperation struct {
		dyngo.Operation
		*trace.ServiceEntrySpanOperation

		// context is an atomic pointer to the current WAF context.
		// Makes sure the calls to context.Run are safe.
		context atomic.Pointer[waf.Context]
		// limiter comes from the WAF feature and is used to limit the number of events as a whole.
		limiter limiter.Limiter
		// events is where we store WAF events received from the WAF over the course of the request.
		events []any
		// stacks is where we store stack traces received from the WAF over the course of the request.
		stacks []*stacktrace.Event
		// derivatives is where we store any span tags generated by the WAF over the course of the request.
		derivatives map[string]any
		// supportedAddresses is the set of addresses supported by the WAF.
		supportedAddresses config.AddressSet
		// mu protects the events, stacks, and derivatives, supportedAddresses slices.
		mu sync.Mutex
		// logOnce is used to log a warning once when a request has too many WAF events via the built-in limiter or the max value.
		logOnce sync.Once
	}

	ContextArgs struct{}

	ContextRes struct{}

	// RunEvent is the type of event that should be emitted to child operations to run the WAF
	RunEvent struct {
		waf.RunAddressData
		dyngo.Operation
	}
)

func (ContextArgs) IsArgOf(*ContextOperation)   {}
func (ContextRes) IsResultOf(*ContextOperation) {}

func StartContextOperation(ctx context.Context) (*ContextOperation, context.Context) {
	entrySpanOp, ctx := trace.StartServiceEntrySpanOperation(ctx)
	op := &ContextOperation{
		Operation:                 dyngo.NewOperation(entrySpanOp),
		ServiceEntrySpanOperation: entrySpanOp,
	}
	return op, dyngo.StartAndRegisterOperation(ctx, op, ContextArgs{})
}

func (op *ContextOperation) Finish(span trace.TagSetter) {
	dyngo.FinishOperation(op, ContextRes{})
	op.ServiceEntrySpanOperation.Finish(span)
}

func (op *ContextOperation) SwapContext(ctx *waf.Context) *waf.Context {
	return op.context.Swap(ctx)
}

func (op *ContextOperation) SetLimiter(limiter limiter.Limiter) {
	op.limiter = limiter
}

func (op *ContextOperation) AddEvents(events ...any) {
	if len(events) == 0 {
		return
	}

	if !op.limiter.Allow() {
		log.Warn("appsec: too many WAF events, stopping further reporting")
		return
	}

	op.mu.Lock()
	defer op.mu.Unlock()

	const maxWAFEventsPerRequest = 10
	if len(op.events) >= maxWAFEventsPerRequest {
		op.logOnce.Do(func() {
			log.Warn("appsec: ignoring new WAF event due to the maximum number of security events per request was reached")
		})
		return
	}

	op.events = append(op.events, events...)
}

func (op *ContextOperation) AddStackTraces(stacks ...*stacktrace.Event) {
	if len(stacks) == 0 {
		return
	}

	op.mu.Lock()
	defer op.mu.Unlock()
	op.stacks = append(op.stacks, stacks...)
}

func (op *ContextOperation) AbsorbDerivatives(derivatives map[string]any) {
	if len(derivatives) == 0 {
		return
	}

	op.mu.Lock()
	defer op.mu.Unlock()
	if op.derivatives == nil {
		op.derivatives = make(map[string]any)
	}

	for k, v := range derivatives {
		op.derivatives[k] = v
	}
}

func (op *ContextOperation) Derivatives() map[string]any {
	op.mu.Lock()
	defer op.mu.Unlock()
	return maps.Clone(op.derivatives)
}

func (op *ContextOperation) Events() []any {
	op.mu.Lock()
	defer op.mu.Unlock()
	return slices.Clone(op.events)
}

func (op *ContextOperation) StackTraces() []*stacktrace.Event {
	op.mu.Lock()
	defer op.mu.Unlock()
	return slices.Clone(op.stacks)
}

func (op *ContextOperation) OnEvent(event RunEvent) {
	op.Run(event.Operation, event.RunAddressData)
}

func (op *ContextOperation) SetSupportedAddresses(addrs config.AddressSet) {
	op.supportedAddresses = addrs
}
